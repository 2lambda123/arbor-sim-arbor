#!/usr/bin/env python3

import subprocess as sp
import sys
from tempfile import TemporaryDirectory
import os
from pathlib import Path
import shutil
import stat
import string
import argparse

def parse_arguments():
    def append_slash(s):
        return s+'/' if s and not s.endswith('/') else s

    class ConciseHelpFormatter(argparse.HelpFormatter):
        def __init__(self, **kwargs):
            super(ConciseHelpFormatter, self).__init__(max_help_position=20, **kwargs)

        def _format_action_invocation(self, action):
            if not action.option_strings:
                return super(ConciseHelpFormatter, self)._format_action_invocation(action)
            else:
                optstr = ', '.join(action.option_strings)
                if action.nargs==0:
                    return optstr
                else:
                    return optstr+' '+self._format_args(action, action.dest.upper())

    parser = argparse.ArgumentParser(
        description = 'Generate dynamic catalogue and build it into a shared object.',
        usage = '%(prog)s [options] [module...]',
        add_help = False,
        formatter_class = ConciseHelpFormatter)

    group = parser.add_argument_group('Options')

    group.add_argument(
        '-I', '--module-prefix',
        default = 'mechanisms',
        metavar = 'PATH',
        dest = 'modpfx',
        type = append_slash,
        help = 'directory prefix for module includes, default "%(default)s"')

    group.add_argument(
        '-S', '--arbor-source',
        default = '',
        metavar = 'PATH',
        dest = 'arbsrc',
        type = append_slash,
        help = 'directory prefix for arbor source tree, default "%(default)s"')

    group.add_argument(
        '-A', '--arbor-prefix',
        default = '',
        metavar = 'PATH',
        dest = 'arbpfx',
        type = append_slash,
        help = 'directory prefix for arbor includes, default "%(default)s"')

    group.add_argument(
        '-B', '--backend',
        default = [],
        action = 'append',
        dest = 'backends',
        metavar = 'BACKEND',
        help = 'register implementations for back-end %(metavar)s')

    group.add_argument(
        '-N', '--namespace',
        default = ['arb::catalogue'],
        action = 'append',
        dest = 'namespaces',
        metavar = 'NAMESPACE',
        help = 'add %(metavar)s to list of implicitly included namespaces')

    group.add_argument(
        '-C', '--catalogue',
        default = 'default',
        dest = 'catalogue',
        help = 'catalogue name, default "%(default)s"')

    group.add_argument(
        '-h', '--help',
        action = 'help',
        help = 'display this help and exit')

    return vars(parser.parse_args())

cmake = r"""cmake_minimum_required(VERSION 3.19)

project(catalogue LANGUAGES CXX)

find_package(arbor REQUIRED)

set(external_modcc MODCC "/usr/local/bin/modcc")
if(ARB_WITH_EXTERNAL_MODCC)
    set(external_modcc MODCC ${{modcc}})
endif()

include(BuildModules.cmake)

set(CMAKE_CXX_COMPILER ${{ARB_CXX}})
set(CMAKE_CXX_FLAGS ${{ARB_CXX_FLAGS}} ${{ARB_CXXOPT_ARCH}})

make_catalogue(
  NAME ${NAME}
  SOURCES "${CMAKE_CURRENT_BINARY_DIR}/${NAME}"
  OUTPUT "CAT_${NAME}_SOURCES"
  MECHS CaDynamics Cqa_HVA Ca_LVA Ih Im Im_v2 K_P K_T Kd Kv2like Kv3_1 NaTa NaTs NaV Nap SK)

set(CMAKE_SHARED_LIBRARY_PREFIX "")
set(CMAKE_SHARED_LIBRARY_SUFFIX ".so")

add_library(${{target}} SHARED ${{cat_src}})
set_property(TARGET ${{target}} PROPERTY CXX_STANDARD 17)
# this is a terrible hack to get `backends' into scope
target_include_directories(${{target}} PUBLIC {arb_src}/arbor)
# bring generated source into scope
target_include_directories(${{target}} PUBLIC ${{out_dir}})
target_link_libraries(${{target}} PRIVATE arbor::arbor)
"""

cat_src = string.Template(r'''// Automatically generated by:
// $cmdline

#include <${arbpfx}mechcat.hpp>
$backend_includes
$module_includes
$using_namespace

namespace arb {

mechanism_catalogue build_${catalogue}_catalogue() {
    mechanism_catalogue cat;

    $add_modules
    $register_modules
    return cat;
}

const mechanism_catalogue& global_${catalogue}_catalogue() {
    static mechanism_catalogue cat = build_${catalogue}_catalogue();
    return cat;
}

} // namespace arb

extern "C" {
    const arb::mechanism_catalogue& get_catalogue() {
        static auto cat = arb::build_allen_catalogue();
        return cat;
    }
}
''')


def generate(catalogue, modpfx='', arbpfx='', modules=[], backends=[], namespaces=[], **rest):
    def indent(n, lines):
        return '{{:<{0!s}}}'.format(n+1).format('\n').join(lines)

    result = cat_src.safe_substitute(dict(
        cmdline=" ".join(sys.argv),
        arbpfx=arbpfx,
        catalogue=catalogue,
        using_namespace = indent(0,
            ['using namespace {};'.format(n) for n in namespaces]),
        backend_includes = indent(0,
            ['#include "backends/{}/fvm.hpp"'.format(b) for b in backends]),
        module_includes = indent(0,
            ['#include "{}.hpp"'.format(m) for m in modules]),
        add_modules = indent(4,
            ['cat.add("{0}", mechanism_{0}_info());'.format(m) for m in modules]),
        register_modules = indent(4,
            ['cat.register_implementation("{0}", make_mechanism_{0}<{1}::backend>());'.format(m, b)
             for m in modules for b in backends])
        ))
    return result

args = parse_arguments()

name    = args['catalogue']
mod_dir = Path(args['modpfx'])
arb_src = Path(args['arbsrc'])
args['modules'] = [ f[:-4] for f in os.listdir(mod_dir) if f.endswith('.mod') ]

code = generate(**args)

pwd = Path.cwd()

with TemporaryDirectory() as tmp:
    tmp = Path(tmp)
    shutil.copytree(pwd / mod_dir, tmp / mod_dir)
    os.mkdir(tmp / 'build')
    os.mkdir(tmp / 'build' / mod_dir)
    os.chdir(tmp)
    with open('BuildModules.cmake', 'w') as fd:
        fd.write(build)
    print(arb_src)
    with open(tmp / 'CMakeLists.txt', 'w') as fd:
        fd.write(cmake.format(name=name, mods=' '.join(args['modules']), arb_src=arb_src))
    with open(tmp / 'build' / mod_dir / 'catalogue.cpp', 'w') as fd:
        fd.write(code)
    os.chdir('build')
    sp.run('cmake ..', shell=True)
    sp.run('make VERBOSE=1', shell=True)
    shutil.copy2(f'{name}_catalogue.so', pwd)
