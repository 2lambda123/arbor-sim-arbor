#include "gtest.h"
#include "../test_util.hpp"

// Prototype mechanisms in tests
#include "../mechanisms/expsyn.hpp"
#include "../mechanisms/exp2syn.hpp"

#include <algorithm>
#include <type_traits>
#include <cell.hpp>
#include <fvm_cell.hpp>

// modcc generated mechanisms
#include <mechanisms/expsyn.hpp>
#include <mechanisms/exp2syn.hpp>

// compares results with those generated by nrn/ball_and_stick.py
TEST(synapses, add_to_cell)
{
    using namespace nest::mc;

    nest::mc::cell cell;

    // setup global state for the mechanisms
    // nest::mc::mechanisms::setup_mechanism_helpers();

    // Soma with diameter 12.6157 um and HH channel
    auto soma = cell.add_soma(12.6157/2.0);
    soma->add_mechanism(hh_parameters());

    parameter_list exp_default("expsyn");
    parameter_list exp2_default("exp2syn");

    cell.add_synapse({0, 0.1}, exp_default);
    cell.add_synapse({1, 0.2}, exp2_default);
    cell.add_synapse({0, 0.3}, exp_default);

    EXPECT_EQ(3u, cell.synapses().size());
    const auto& syns = cell.synapses();

    EXPECT_EQ(syns[0].location.segment, 0u);
    EXPECT_EQ(syns[0].location.position, 0.1);
    EXPECT_EQ(syns[0].mechanism.name(), "expsyn");

    EXPECT_EQ(syns[1].location.segment, 1u);
    EXPECT_EQ(syns[1].location.position, 0.2);
    EXPECT_EQ(syns[1].mechanism.name(), "exp2syn");

    EXPECT_EQ(syns[2].location.segment, 0u);
    EXPECT_EQ(syns[2].location.position, 0.3);
    EXPECT_EQ(syns[2].mechanism.name(), "expsyn");
}

template<typename T>
void mech_update(T* mech, int num_iters) {
    mech->nrn_init();
    for (auto i = 0; i < mech->node_index_.size(); ++i) {
        mech->net_receive(i, 1.);
    }

    for (auto i = 0; i < num_iters; ++i) {
        mech->nrn_current();
        mech->nrn_state();
    }
}

// compares results with those generated by nrn/ball_and_stick.py
TEST(synapses, expsyn_basic_state)
{
    using namespace nest::mc;

    using synapse_type = mechanisms::expsyn::mechanism_expsyn<double, int>;
    auto num_syn = 4;

    synapse_type::index_type indexes(num_syn);
    synapse_type::vector_type voltage(num_syn, -65.0);
    synapse_type::vector_type current(num_syn,   1.0);
    auto mech = mechanisms::make_mechanism<synapse_type>( voltage, current, indexes );

    auto ptr = dynamic_cast<synapse_type*>(mech.get());

    auto n = ptr->size();
    EXPECT_EQ(num_syn, n);

    using view = synapse_type::view_type;

    // parameters initialized to default values
    for(auto e : view(ptr->e, n)) {
        EXPECT_EQ(e, 0.);
    }
    for(auto tau : view(ptr->tau, n)) {
        EXPECT_EQ(tau, 2.0);
    }

    // current and voltage vectors correctly hooked up
    for(auto v : view(ptr->vec_v_, n)) {
        EXPECT_EQ(v, -65.);
    }
    for(auto i : view(ptr->vec_i_, n)) {
        EXPECT_EQ(i, 1.0);
    }

    // should be initialized to NaN
    for(auto g : view(ptr->g, n)) {
        EXPECT_NE(g, g);
    }

    // initialize state then check g has been set to zero
    ptr->nrn_init();
    for(auto g : view(ptr->g, n)) {
        EXPECT_EQ(g, 0.);
    }

    // call net_receive on two of the synapses
    ptr->net_receive(1, 3.14);
    ptr->net_receive(3, 1.04);
    EXPECT_EQ(ptr->g[1], 3.14);
    EXPECT_EQ(ptr->g[3], 1.04);

}

TEST(synapses, exp2syn_basic_state)
{
    using namespace nest::mc;

    using synapse_type = mechanisms::exp2syn::mechanism_exp2syn<double, int>;
    auto num_syn = 4;

    synapse_type::index_type indexes(num_syn);
    synapse_type::vector_type voltage(num_syn, -65.0);
    synapse_type::vector_type current(num_syn,   1.0);
    auto mech = mechanisms::make_mechanism<synapse_type>( voltage, current, indexes );

    auto ptr = dynamic_cast<synapse_type*>(mech.get());

    auto n = ptr->size();
    using view = synapse_type::view_type;

    // parameters initialized to default values
    for(auto e : view(ptr->e, n)) {
        EXPECT_EQ(e, 0.);
    }
    for(auto tau1: view(ptr->tau1, n)) {
        EXPECT_EQ(tau1, 0.5);
    }
    for(auto tau2: view(ptr->tau2, n)) {
        EXPECT_EQ(tau2, 2.0);
    }

    // should be initialized to NaN
    for(auto factor: view(ptr->factor, n)) {
        EXPECT_NE(factor, factor);
    }

    // initialize state then check factor has sane (positive) value
    // and A and B are zero
    ptr->nrn_init();
    for(auto factor: view(ptr->factor, n)) {
        EXPECT_GT(factor, 0.);
    }
    for(auto A: view(ptr->A, n)) {
        EXPECT_EQ(A, 0.);
    }
    for(auto B: view(ptr->B, n)) {
        EXPECT_EQ(B, 0.);
    }

    // call net_receive on two of the synapses
    ptr->net_receive(1, 3.14);
    ptr->net_receive(3, 1.04);

    EXPECT_NEAR(ptr->A[1], ptr->factor[1]*3.14, 1e-6);
    EXPECT_NEAR(ptr->B[3], ptr->factor[3]*1.04, 1e-6);
}

template<typename S, typename T, bool alias=true>
struct synapse_pair {
    using synapse_type = S;
    using proto_synapse_type = T;
    static constexpr bool alias = alias;
};

template<typename T>
class synapses : public ::testing::Test { };

TYPED_TEST_CASE_P(synapses);

TYPED_TEST_P(synapses, mechanism) {
    using namespace nest::mc;

    using synapse_type = typename TypeParam::synapse_type;
    using proto_synapse_type = typename TypeParam::proto_synapse_type;

    // Type checking
    EXPECT_TRUE((std::is_same<typename proto_synapse_type::index_type,
                              typename synapse_type::index_type>::value));
    EXPECT_TRUE((std::is_same<typename proto_synapse_type::value_type,
                              typename synapse_type::value_type>::value));
    EXPECT_TRUE((std::is_same<typename proto_synapse_type::vector_type,
                              typename synapse_type::vector_type>::value));

    auto num_syn = 8;

    // Indexes are aliased
    typename synapse_type::index_type indexes(num_syn);
    typename synapse_type::vector_type voltage(num_syn, -65.0);
    typename synapse_type::vector_type current(num_syn,   1.0);
    typename synapse_type::vector_type areas(num_syn, 2);

    // Initialise indexes
    for (auto i = 0; i < num_syn; ++i) {
        indexes[i] = TypeParam::alias ? 1 : i;
    }

    auto mech = mechanisms::make_mechanism<synapse_type>(
        voltage, current, indexes
    );

    // Create a prototype mechanism that we will check against it
    auto indexes_copy = indexes;
    auto voltage_copy = voltage;
    auto current_copy = current;
    auto mech_proto = mechanisms::make_mechanism<proto_synapse_type>(
        voltage_copy, current_copy, indexes_copy
    );

    mech->set_areas(areas);
    mech_proto->set_areas(areas);
    mech->set_params(2., 0.1);
    mech_proto->set_params(2., 0.1);
    mech_update(dynamic_cast<synapse_type*>(mech.get()), 2);
    mech_update(dynamic_cast<proto_synapse_type*>(mech_proto.get()), 2);

    auto citer = current_copy.begin();
    for (auto const& c: current) {
        EXPECT_EQ(*citer++, c);
    }
}

REGISTER_TYPED_TEST_CASE_P(synapses, mechanism);

using synapse_types = ::testing::Types<
    synapse_pair<
        nest::mc::mechanisms::expsyn::mechanism_expsyn<double, int>,
        nest::mc::mechanisms::expsyn_test::mechanism_expsyn<double, int>
    >,
    synapse_pair<
        nest::mc::mechanisms::exp2syn::mechanism_exp2syn<double, int>,
        nest::mc::mechanisms::exp2syn_test::mechanism_exp2syn<double, int>
    >
>;

INSTANTIATE_TYPED_TEST_CASE_P(synapse_types, synapses, synapse_types);
